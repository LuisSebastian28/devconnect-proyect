"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpClient = void 0;
const errors_1 = require("./errors");
/**
 * HTTP client for making authenticated requests to the Livy SDK API.
 *
 * Handles authentication, retry logic with exponential backoff, timeout management,
 * and error mapping from HTTP responses to structured SDK errors.
 */
class HttpClient {
    /**
     * Creates a new HTTP client with the specified configuration.
     *
     * @param config - HTTP client configuration including API key and request settings
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * Makes an authenticated request to the service execution endpoint.
     *
     * Sends a POST request to execute a service with optional attestation and data availability posting.
     * Uses the SDK endpoint format with serviceId in the request body.
     *
     * @param params - Execution parameters containing service ID, params, and execution options
     * @returns Promise resolving to the raw execution response data
     * @throws {SDKError} When the request fails or returns an error status
     */
    async run(params) {
        // Build the SDK URL: /api/proxy/runwithra (no params in URL)
        const endpoint = params.withAttestation !== false ? 'runwithra' : 'run'; // Default to with attestation
        const url = `${this.config.baseUrl}/${endpoint}`;
        const requestData = {
            serviceId: params.serviceId,
            ...(params.params && Object.keys(params.params).length > 0 && { params: params.params }),
            ...(params.postToDataAvailability && { postToDataAvailability: params.postToDataAvailability })
        };
        console.log(`Making request to: ${url}`);
        return this.makeRequest(url, {
            method: 'POST',
            headers: this.buildHeaders(),
            body: JSON.stringify(requestData)
        });
    }
    /**
     * Makes a request to the attestation verification endpoint.
     *
     * Sends a POST request to verify an attestation quote using the SDK verification service.
     * This endpoint is used for standalone attestation verification.
     *
     * @param verificationData - The verification payload containing quote, eventLog, and RTMRs
     * @returns Promise resolving to the verification response data
     * @throws {SDKError} When the request fails or returns an error status
     */
    async verify(verificationData) {
        const url = `${this.config.baseUrl}/verify`;
        console.log(`Making verification request to: ${url}`);
        return this.makeRequest(url, {
            method: 'POST',
            headers: this.buildHeaders(),
            body: JSON.stringify(verificationData)
        });
    }
    /**
     * Posts data to the Celestia data availability layer.
     *
     * Sends a POST request to publish data to Celestia through the /celestia/publish endpoint.
     *
     * @param data - Data to post to Celestia (can be string or any JSON-serializable data)
     * @param namespace - Optional hex namespace (defaults to custom Livy namespace)
     * @returns Promise resolving to Celestia publication result
     * @throws {SDKError} When the request fails or returns an error status
     */
    async postToDataAvailability(data, namespace) {
        const url = `${this.config.baseUrl}/celestia/publish`;
        const requestData = {
            data,
            ...(namespace && { namespace })
        };
        console.log(`Making Celestia publish request to: ${url}`);
        return this.makeRequest(url, {
            method: 'POST',
            headers: this.buildHeaders(),
            body: JSON.stringify(requestData)
        });
    }
    /**
     * Gets blob data from the Celestia data availability layer.
     *
     * Sends a POST request to retrieve blob data from Celestia through the /celestia/get endpoint.
     *
     * @param params - Parameters for blob retrieval including height, commitment, namespace, or height range
     * @returns Promise resolving to Celestia retrieval result
     * @throws {SDKError} When the request fails or returns an error status
     */
    async getFromCelestia(params) {
        const url = `${this.config.baseUrl}/celestia/get`;
        console.log(`Making Celestia get request to: ${url}`);
        return this.makeRequest(url, {
            method: 'POST',
            headers: this.buildHeaders(),
            body: JSON.stringify(params)
        });
    }
    /**
     * Makes an HTTP request with retry logic and error handling.
     *
     * Implements exponential backoff for retries, handles various error conditions,
     * and converts HTTP errors to structured SDK errors.
     *
     * @param url - Target URL for the request
     * @param options - Fetch options including method, headers, and body
     * @returns Promise resolving to the parsed JSON response
     * @throws {SDKError} When all retry attempts are exhausted or non-retryable errors occur
     */
    async makeRequest(url, options) {
        let lastError = null;
        for (let attempt = 0; attempt <= this.config.retries; attempt++) {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);
                const response = await fetch(url, {
                    ...options,
                    signal: controller.signal,
                });
                clearTimeout(timeoutId);
                if (!response.ok) {
                    const errorText = await response.text();
                    let errorMessage;
                    try {
                        const errorJson = JSON.parse(errorText);
                        errorMessage = errorJson.message || errorJson.error || errorJson.details || errorText;
                    }
                    catch {
                        errorMessage = errorText;
                    }
                    throw errors_1.SDKError.fromHttpStatus(response.status, errorMessage);
                }
                const responseText = await response.text();
                try {
                    return JSON.parse(responseText);
                }
                catch (parseError) {
                    throw new errors_1.SDKError('NETWORK_ERROR', 'Invalid JSON response from server');
                }
            }
            catch (error) {
                lastError = error;
                // Don't retry certain errors
                if (error instanceof errors_1.SDKError) {
                    if (['INVALID_API_KEY', 'SERVICE_NOT_FOUND', 'INVALID_PARAMS'].includes(error.code)) {
                        throw error;
                    }
                }
                // Handle fetch abort (timeout)
                if (error.name === 'AbortError') {
                    lastError = errors_1.SDKError.timeoutError();
                    if (attempt === this.config.retries) {
                        throw lastError;
                    }
                    continue;
                }
                // Handle network errors
                if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED' || error.code === 'ETIMEDOUT') {
                    lastError = errors_1.SDKError.networkError(`Network error: ${error.message}`);
                    if (attempt === this.config.retries) {
                        throw lastError;
                    }
                    continue;
                }
                // Re-throw SDK errors immediately
                if (error instanceof errors_1.SDKError) {
                    throw error;
                }
                // For unknown errors, convert to SDK error
                lastError = errors_1.SDKError.networkError(`Request failed: ${error.message}`);
                if (attempt === this.config.retries) {
                    throw lastError;
                }
                // Wait before retry (exponential backoff)
                if (attempt < this.config.retries) {
                    await this.delay(Math.pow(2, attempt) * 1000);
                }
            }
        }
        throw lastError || errors_1.SDKError.networkError('Request failed after all retries');
    }
    /**
     * Creates a delay for retry operations.
     *
     * @param ms - Number of milliseconds to delay
     * @returns Promise that resolves after the specified delay
     */
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    /**
     * Builds the headers for authenticated requests.
     *
     * @returns Object containing headers for authentication and content type
     */
    buildHeaders() {
        const headers = new Headers();
        headers.set('Content-Type', 'application/json');
        headers.set('Authorization', `Bearer ${this.config.apiKey}`);
        return headers;
    }
}
exports.HttpClient = HttpClient;
