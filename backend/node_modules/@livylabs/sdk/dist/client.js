"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SDKClient = void 0;
const http_client_1 = require("./http-client");
const attestation_result_1 = require("./attestation-result");
const errors_1 = require("./errors");
/**
 * Main SDK client implementation for executing services with attestation verification.
 *
 * This class orchestrates HTTP requests to the Livy proxy API and wraps responses
 * in AttestationResult objects that provide verification capabilities.
 */
class SDKClient {
    /**
     * Creates a new SDK client instance with the specified configuration.
     *
     * @param config - Configuration object with API key and optional settings
     */
    constructor(config) {
        // Set default values
        const finalConfig = {
            apiKey: config.apiKey,
            baseUrl: config.baseUrl || 'https://console.livylabs.xyz/api/proxy',
            timeout: config.timeout || 30000,
            retries: config.retries || 3,
        };
        this.baseUrl = finalConfig.baseUrl;
        this.httpClient = new http_client_1.HttpClient(finalConfig);
    }
    /**
     * @inheritDoc
     */
    async run(params) {
        // Validate parameters
        if (!params.serviceId) {
            throw new Error('serviceId is required');
        }
        if (params.params !== undefined && typeof params.params !== 'object') {
            throw new Error('params must be a valid object when provided');
        }
        // Make the HTTP request
        const responseData = await this.httpClient.run(params);
        let dataAvailabilityResult;
        if (params.postToDataAvailability) {
            try {
                const dataToPost = {
                    output: responseData.output,
                    ...(responseData.quote && { quote: responseData.quote }),
                };
                dataAvailabilityResult = await this.postToDataAvailability(dataToPost);
            }
            catch (daError) {
                console.warn('Failed to post to data availability:', daError);
            }
        }
        // Return wrapped result with verification capabilities
        return new attestation_result_1.AttestationResultImpl(responseData, params.serviceId, params.params || {}, params.withAttestation !== false, params.postToDataAvailability || false, this.baseUrl, dataAvailabilityResult);
    }
    /**
     * @inheritDoc
     */
    async verifyAttestation(quoteData) {
        try {
            // Validate required quote data
            if (!quoteData.quote) {
                throw new Error('quote is required');
            }
            if (!quoteData.eventLog) {
                throw new Error('eventLog is required');
            }
            if (!quoteData.rtmrs || !Array.isArray(quoteData.rtmrs) || quoteData.rtmrs.length !== 4) {
                throw new Error('rtmrs must be an array of 4 hex strings');
            }
            // Prepare verification payload - compatible with existing backend format
            const verificationPayload = {
                quote: quoteData.quote,
                eventLog: quoteData.eventLog,
                rtmrs: quoteData.rtmrs,
                rtms: quoteData.rtmrs.join(',') // For backward compatibility
            };
            // Make the verification request
            const response = await this.httpClient.verify(verificationPayload);
            // Ensure we have a valid response object
            if (typeof response !== 'object' || response === null) {
                throw errors_1.SDKError.verificationFailed('Invalid response format from verification service');
            }
            // Return the response directly, ensuring we have at least a message field
            const result = {
                message: response.message || 'Verification completed',
                report_data: response.report_data,
                ...response
            };
            return result;
        }
        catch (error) {
            if (error instanceof errors_1.SDKError) {
                throw error;
            }
            throw errors_1.SDKError.verificationFailed(`Attestation verification failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    /**
     * @inheritDoc
     */
    async postToDataAvailability(data, namespace) {
        try {
            // Validate required data
            if (data === undefined || data === null) {
                throw new Error('data is required');
            }
            // Make the request to post to Celestia
            const response = await this.httpClient.postToDataAvailability(data, namespace);
            // Ensure we have a valid response object
            if (typeof response !== 'object' || response === null) {
                throw errors_1.SDKError.networkError('Invalid response format from Celestia service');
            }
            // Return the response, ensuring we have the required fields
            const result = {
                success: response.success ?? false,
                height: response.height ?? 0,
                namespace: response.namespace ?? '',
                message: response.message ?? 'Data posted to Celestia',
                ...(response.commitment && { commitment: response.commitment })
            };
            return result;
        }
        catch (error) {
            if (error instanceof errors_1.SDKError) {
                throw error;
            }
            throw errors_1.SDKError.networkError(`Failed to post to data availability: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    /**
     * @inheritDoc
     */
    async getFromCelestia(params) {
        try {
            // Validate that at least one retrieval method is provided
            if (!params.height && !params.commitment) {
                throw new Error('Either height, commitment parameter is required');
            }
            // Make the request to get from Celestia
            const response = await this.httpClient.getFromCelestia(params);
            // Ensure we have a valid response object
            if (typeof response !== 'object' || response === null) {
                throw errors_1.SDKError.networkError('Invalid response format from Celestia retrieval service');
            }
            // Return the response, ensuring we have the required fields
            const result = {
                success: response.success ?? false,
                namespace: response.namespace ?? '',
                height: response.height,
                commitment: response.commitment,
                blobs: response.blobs ?? [],
                count: response.count ?? 0
            };
            return result;
        }
        catch (error) {
            if (error instanceof errors_1.SDKError) {
                throw error;
            }
            throw errors_1.SDKError.networkError(`Failed to get from Celestia: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
}
exports.SDKClient = SDKClient;
